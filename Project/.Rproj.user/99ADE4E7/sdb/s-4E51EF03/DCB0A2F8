{
    "collab_server" : "",
    "contents" : "---\noutput: html_document\n---\n---\ntitle: \"<center><h1>Detailed Data Analysis & Ensemble Modeling</h1></center>\"\nauthor: \n  \"<center>Tanner Carbonati</center>\"\ndate: \"<center>April 5, 2017</center>\"\noutput:\n  pdf_document: default\n  html_document:\n    keep_md: yes\n---\n\n  There have been a lot of great scripts/notebooks for this dataset and I thought I would share my own. This was written for a course at UCSD so I did my best to go through intensive detail and include the theory used for cleaning the data and training models. The model used for training is an ensemble of XGBoost, Ridge, Lasso and Elastic-Net regularization. Many of ideas used in this notebook were influenced by a few other kernels including:\n  \n- https://www.kaggle.com/opanichev/house-prices-advanced-regression-techniques/ensemble-of-4-models-with-cv-lb-0-11489\n- https://www.kaggle.com/humananalog/house-prices-advanced-regression-techniques/xgboost-lasso\n\n  Our goal is to transform all of our data into numeric, while preserving as much information from the categoric variables as we're going to use a gradient boosting method (XGBoost). As XGBoost has trouble with extrapolation we will use ridge, lasso and elastic-net regularization, which will also account for a lot of the multicollinearity in the data. Once we have predictions from all 4 regressors we can average the results to get an accurate estimate.  We'll go more in depth on why we chose these methods and how we'll use them later on. \n  \nLet the fun begin!\n\n```{r warning=FALSE, message=FALSE}\nrequire(ggplot2) # for data visualization\nrequire(stringr) #extracting string patterns\nrequire(Matrix) # matrix transformations\nrequire(glmnet) # ridge, lasso & elastinet\nrequire(xgboost) # gbm\nrequire(randomForest)\nrequire(Metrics) # rmse\nrequire(dplyr) # load this in last so plyr doens't overlap it\nrequire(caret) # one hot encoding\nrequire(scales) # plotting $$\nrequire(e1071) # skewness\nrequire(corrplot) # correlation plot\n```\n\nThe first thing we'll do is load in the training and testing data. The training data consists of 1460 rows and 81 columns while the testing has 1459 rows and 80 columns (excluding the `SalePrice` column), which in this dataset is the dependent variable we are trying to predict. For us to perform analysis at a more productive rate we can combine the 2 dataframes together and run analysis on both data sets at once, then split the data once we are ready to train a model. \n\nThe `Id` feature is useless so we can toss it out of our dataset and we won't include `SalePrice` since it is our response variable. We also won't import string variables as factors since our ultimate goal is to tranform all our variables to numeric. \n\n```{r warning=FALSE, message=FALSE}\ntrain <- read.csv('../input/train.csv', stringsAsFactors = FALSE)\ntest <- read.csv('../input/test.csv', stringsAsFactors = FALSE)\n\n\n# combine the datasets\ndf.combined <- rbind(within(train, rm('Id','SalePrice')), within(test, rm('Id')))\ndim(df.combined)\n```\n\nOur dataset is filled with many missing values, therefore, before we can build any predictive model we'll clean our data by filling in all NA's with appropriate values. For each column we'll try to replace NA's by using features that have a strong correlation, which will help us determine what values to fill in. \n\n```{r warning=FALSE, message=FALSE}\nna.cols <- which(colSums(is.na(df.combined)) > 0)\nsort(colSums(sapply(df.combined[na.cols], is.na)), decreasing = TRUE)\npaste('There are', length(na.cols), 'columns with missing values')\n```\n\n```{r}\n# helper function for plotting categoric data for easier data visualization\nplot.categoric <- function(cols, df){\n  for (col in cols) {\n    order.cols <- names(sort(table(df.combined[,col]), decreasing = TRUE))\n  \n    num.plot <- qplot(df[,col]) +\n      geom_bar(fill = 'cornflowerblue') +\n      geom_text(aes(label = ..count..), stat='count', vjust=-0.5) +\n      theme_minimal() +\n      scale_y_continuous(limits = c(0,max(table(df[,col]))*1.1)) +\n      scale_x_discrete(limits = order.cols) +\n      xlab(col) +\n      theme(axis.text.x = element_text(angle = 30, size=12))\n  \n    print(num.plot)\n  }\n}\n\n```\n\n**PoolQC: Pool quality**\n\nThere are 2909 missing values in PoolQC, which represents the quality of the houses pool. It is a reasonable assumption that houses with NA's for PoolQC most likely don't have a pool, however, for us to check this we can see if any of the houses that have a NA for PoolQC recorded a PoolArea > 0 (**PoolArea:** Pool area in square feet). it is safe to assume that houses with a PoolArea of 0 don't have a pool and for those greater than 0 do. \n\n```{r warning=FALSE, message=FALSE}\nplot.categoric('PoolQC', df.combined)\ndf.combined[(df.combined$PoolArea > 0) & is.na(df.combined$PoolQC),c('PoolQC','PoolArea')]\n```\n\nOf the 2909 houses with NA's for PoolQC only 3 recorded a PoolArea greater than 0. To fill the missing values for these houses we can see what the mean pool area is for each quality of pool. To do this we'll group by each unique vlaue of `PoolQC` and compute the mean of PoolArea for that quality. Once we have the mean areas computed we can assign the quality that has the closest corresponding mean of PoolArea\n\n```{r warning=FALSE, message=FALSE}\ndf.combined[,c('PoolQC','PoolArea')] %>%\n  group_by(PoolQC) %>%\n  summarise(mean = mean(PoolArea), counts = n()) \n\n```\n\nNote that only 10 houses total have pools  The rest of the houses PoolQC can be filled with 'NoPool' since each has a corresponding PoolArea of 0. We'll fill in the 3 PoolQC's from above with the quality having the closest corresponding mean. \n\n\n```{r warning=FALSE, message=FALSE}\ndf.combined[2421,'PoolQC'] = 'Ex'\ndf.combined[2504,'PoolQC'] = 'Ex'\ndf.combined[2600,'PoolQC'] = 'Fa'\ndf.combined$PoolQC[is.na(df.combined$PoolQC)] = 'None'\n```\n\n**GarageType: Garage location**  \n**GarageYrBlt: Year garage was built**  \n**GarageFinish: Interior finish of the garage**  \n**GarageCars: Size of garage in car capacity**  \n**GarageArea: Size of garage in square feet**  \n**GarageQual: Garage quality**  \n**GarageCond: Garage condition**  \n\nLets see what the deal is with `GarageYrBlt`. It seems reasonable that most houses would build a garage when the house itself was built. We can check this by seeing how many houses were built the same year their garage was built. \n\n\n```{r}\nlength(which(df.combined$GarageYrBlt == df.combined$YearBuilt))\n```\n\n2216 of the 2919 houses have same year for for GarageYrBlt and YearBuilt. Lets replace any of the NA's for `GarageYrBlt` with the year from  `YearBuilt`. \n\n```{r}\nidx <- which(is.na(df.combined$GarageYrBlt))\ndf.combined[idx, 'GarageYrBlt'] <- df.combined[idx, 'YearBuilt']\n```\n\nThat leaves 6 garage features in our dataset and 4 of them have at least 157 missing values while `GarageArea` and `GarageCars` both only have 1, thus we can assume this particular house does not have a garage at all. For the rest of the houses we can check to see that if the NA's recorded also have 0 GarageArea and 0 GarageCars. If they do we can fill in their missing values with 'None' since having 0 area and 0 cars in their garage will imply that they do not have any at all. \n\n```{r}\ngarage.cols <- c('GarageArea', 'GarageCars', 'GarageQual', 'GarageFinish', 'GarageCond', 'GarageType')\ndf.combined[is.na(df.combined$GarageCond),garage.cols]\n```\n\nOnly one house who had NA's in their garage columns had an area graeteer than 0. We can fill this house in manually and set the rest of the houses NA's to 0. \n\nFor the house with *GarageArea = 360* and *GarageCars = 1*, but NA's in the other columns, we can use the most frequent values for each columns from houses with a similar area and car count. \n\n```{r warning=FALSE, message=FALSE}\nidx <- which(((df.combined$GarageArea < 370) & (df.combined$GarageArea > 350)) & (df.combined$GarageCars == 1))\n\nnames(sapply(df.combined[idx, garage.cols], function(x) sort(table(x), decreasing=TRUE)[1]))\n  \ndf.combined[2127,'GarageQual'] = 'TA'\ndf.combined[2127, 'GarageFinish'] = 'Unf'\ndf.combined[2127, 'GarageCond'] = 'TA'\n```\n\nNow we can fill in any missing numeric values with 0 and categoric with 'None' since these houses recorded having 0 area and 0 cars in their garage.\n\n```{r warning=FALSE, message=FALSE}\nfor (col in garage.cols){\n  if (sapply(df.combined[col], is.numeric) == TRUE){\n    df.combined[sapply(df.combined[col], is.na), col] = 0\n  }\n  else{\n    df.combined[sapply(df.combined[col], is.na), col] = 'None'\n  }\n}\n```\n\n**KitchenQual: Kitchen quality**  \n**Electrical: Electrical system**  \n\nWith only 1 missing value for `KitchenQual` and `Electrical` each we can fill in the missing value with the most frequent value from each column. \n\n```{r warning=FALSE, message=FALSE}\nplot.categoric('KitchenQual', df.combined)\ndf.combined$KitchenQual[is.na(df.combined$KitchenQual)] = 'TA'\n\nplot.categoric('Electrical', df.combined)\ndf.combined$Electrical[is.na(df.combined$Electrical)] = 'SBrkr'\n```\n\n- **BsmtQual: Height of the basement**  \n- **BsmtCond: General condition of the basement**  \n- **BsmtExposure: Walkout or garden level basement walls**  \n- **BsmtFinType1: Quality of basement finished area**  \n- **BsmtFinSF1: Type 1 finished square feet**  \n- **BsmtFinType2: Quality of second finished area (if present)**  \n- **BsmtFinSF2: Type 2 finished square feet**  \n- **BsmtUnfSF: Unfinished square feet of basement area**  \n- **TotalBsmtSF: Total square feet of basement area**  \n- **BsmtFullBath: Basement full bathrooms**  \n- **BsmtHalfBath: Basement half bathrooms**  \n\nThere are 11 basement features each with at least 1 missing value. We can take a look at the subset of just these columns from our data.\n\n```{r warning=FALSE, message=FALSE}\n\nbsmt.cols <- names(df.combined)[sapply(names(df.combined), function(x) str_detect(x, 'Bsmt'))]\n\ndf.combined[is.na(df.combined$BsmtExposure),bsmt.cols]\nplot.categoric('BsmtExposure', df.combined)\n```\n\nAlmost all of the missing values for  each categoric basement feature comes from houses with 0 on each features corresponding to area. We can fill in these values with 'None' since these houses certainly don't have basements. Rows 949, 1488 and 2349 are the only missing values from BsmtExposure, we can fill this with *No* as that is the most frequent value and these houses most likely don't have any exposure for their basements. The rest of the basement columns corresponding to area will be filled with 0 since they likely don't have a basement and the categoric missing values will be filled with *NoBsmt*. \n\n```{r warning=FALSE, message=FALSE}\ndf.combined[c(949, 1488, 2349), 'BsmtExposure'] = 'No'\n\nfor (col in bsmt.cols){\n  if (sapply(df.combined[col], is.numeric) == TRUE){\n    df.combined[sapply(df.combined[col], is.na),col] = 0\n  }\n  else{\n    df.combined[sapply(df.combined[col],is.na),col] = 'None'\n  }\n}\n```\n\n- **Exterior1st: Exterior covering on house**  \n- **Exterior2nd: Exterior covering on house (if more than one material)** \n\n```{r warning = FALSE, message=FALSE}\n#plot.categoric(c('Exterior1st', 'Exterior2nd'), df.combined)\nidx <- which(is.na(df.combined$Exterior1st) | is.na(df.combined$Exterior2nd))\ndf.combined[idx,c('Exterior1st', 'Exterior2nd')]\n```\n\nThere is only 1 missing value for `Exterior1st` and `Exterior2nd` coming from the same hosue and there aren't any other features that can help us predict what variable should be filled so we can fill this with *'Other'* since the NA is likely due to having an exterior cover that is not listed. \n\n```{r warning=FALSE, message=FALSE}\ndf.combined$Exterior1st[is.na(df.combined$Exterior1st)] = 'Other'\ndf.combined$Exterior2nd[is.na(df.combined$Exterior2nd)] = 'Other'\n\n```\n\n- **SaleType: Type of sale**  \n- **Functional: Home functionality rating**  \n- **Utilities: Type of utilities available**  \n\n`SaleType`, `Functional` and `Utilities` have less than 3 missing values. For SaleType we can see what the SaleCondition of the house was and use a contingency table to see which SaleType and SaleCondition overlap together the most. \n\n```{r warning=FALSE, message=FALSE}\nplot.categoric('SaleType', df.combined)\n\ndf.combined[is.na(df.combined$SaleType),c('SaleCondition')]\n\ntable(df.combined$SaleCondition, df.combined$SaleType)\n```\n\nMost houses with a SaleCondition of 'Normal' almost all have a SaleType of 'WD'. We'll replace the missing value accordingly. \n\n```{r warning=FALSE, message=FALSE}\ndf.combined$SaleType[is.na(df.combined$SaleType)] = 'WD'\n\nplot.categoric('Functional', df.combined)\ndf.combined$Functional[is.na(df.combined$Functional)] = 'Typ'\n```\n\nUtilities only has 1 value for NoSeWa and the rest AllPub. We can drop this feature from our dataset as the house with 'NoSeWa' is from our training set and will have won't help with any predictive modelling\n\n```{r warning=FALSE, message=FALSE}\nplot.categoric('Utilities', df.combined)\nwhich(df.combined$Utilities == 'NoSeWa') # in the training data set\n\n\ncol.drops <- c('Utilities')\ndf.combined <- df.combined[,!names(df.combined) %in% c('Utilities')]\n```\n\n- **MSZoning: The general zoning classification**  \n- **MSSubClass: The building class**  \n\n\nThere are only 4 missing values for MSZoning. We can see what the subclass is for the houses with missing values for Zoning.\n\n```{r warning=FALSE, message=FALSE}\ndf.combined[is.na(df.combined$MSZoning),c('MSZoning','MSSubClass')]\nplot.categoric('MSZoning', df.combined)\n\ntable(df.combined$MSZoning, df.combined$MSSubClass)\n```\n\nFor Subclasses with 20 'RL' has the largest frequency, however, for Subclasses with 30 and 70 'RM' has the most frequency. We will fill the missing values accordingly. \n\n```{r warning=FALSE, message=FALSE}\ndf.combined$MSZoning[c(2217, 2905)] = 'RL'\ndf.combined$MSZoning[c(1916, 2251)] = 'RM'\n```\n\n- **MasVnrType: Masonry veneer type**  \n- **MasVnrArea: Masonry veneer area in square feet**\n\nThere are 23 missing values for `MasVnrArea` and 24 for `MasVnrType`. We can see if both missing values come from the same houses\n\n```{r warning=FALSE, message=FALSE}\ndf.combined[(is.na(df.combined$MasVnrType)) | (is.na(df.combined$MasVnrArea)), c('MasVnrType', 'MasVnrArea')]\n```\n\nAll but one house has missing values for both columns. For houses with NA's on both columns we can fill 0 for the area and None for the type since they likely do not have a masonry veneer. For the house with a MasVnrArea of 198 but NA for MasVnrType we can record the median areas for each type and see which type is closest to 198\n\n```{r warning=FALSE, message=FALSE}\nna.omit(df.combined[,c('MasVnrType','MasVnrArea')]) %>%\n  group_by(na.omit(MasVnrType)) %>%\n  summarise(MedianArea = median(MasVnrArea,na.rm = TRUE), counts = n()) %>%\n  arrange(MedianArea)\n\n#plot.categoric('MasVnrType', df.combined)\n\ndf.combined[2611, 'MasVnrType'] = 'BrkFace'\n```\n\nThe areas we can replace with 0 and types can be replaced with 'None'\n\n```{r warning=FALSE, message=FALSE}\ndf.combined$MasVnrType[is.na(df.combined$MasVnrType)] = 'None'\ndf.combined$MasVnrArea[is.na(df.combined$MasVnrArea)] = 0\n```\n\n- **LotFrontage: Linear feet of street connected to property**  \n\nThere are 486 missing values for LotFrontage, which is quite a lot of values to fill and we can't just replace these with 0. We're given that \"LotFrontage: Linear feet of street connected to property.\" The area of each street connected to the house property is most likely going to have a similar area to other houses in its neighborhood. We can group by each neighborhood and take the median of each LotFrontage and fill the missing values of each LotFrontage based on what neighborhood the house comes from. \n\n```{r warning=FALSE, message=FALSE}\n\ndf.combined['Nbrh.factor'] <- factor(df.combined$Neighborhood, levels = unique(df.combined$Neighborhood))\n\nlot.by.nbrh <- df.combined[,c('Neighborhood','LotFrontage')] %>%\n  group_by(Neighborhood) %>%\n  summarise(median = median(LotFrontage, na.rm = TRUE))\nlot.by.nbrh\n\nidx = which(is.na(df.combined$LotFrontage))\n\nfor (i in idx){\n  lot.median <- lot.by.nbrh[lot.by.nbrh == df.combined$Neighborhood[i],'median']\n  df.combined[i,'LotFrontage'] <- lot.median[[1]]\n}\n```\n\n- **Fence: Fence quality**\n\nWe can replace any missing vlues for Fence and MiscFeature with 'None' as they probably don't have this feature with their property. \n\n```{r warning=FALSE, message=FALSE}\nplot.categoric('Fence', df.combined)\n\ndf.combined$Fence[is.na(df.combined$Fence)] = 'None'\n\n\ntable(df.combined$MiscFeature)\ndf.combined$MiscFeature[is.na(df.combined$MiscFeature)] = 'None'\n```\n\n- **Fireplaces: Number of fireplaces**  \n- **FireplaceQu: Fireplace quality **\n\nFireplaceQu denotes the fireplace quality. We can check to see if any of the missing values for FireplaceQu come from houses that recorded having at least 1 fireplace.\n\n```{r warning=FALSE, message=FALSE}\nplot.categoric('FireplaceQu', df.combined)\nwhich((df.combined$Fireplaces > 0) & (is.na(df.combined$FireplaceQu)))\n```\n\nAll the houses that have missing values did not record having any fireplaces. We can replace the NA's with 'None' since these houses don't have any fireplaces at all. \n\n```{r warning=FALSE, message=FALSE}\ndf.combined$FireplaceQu[is.na(df.combined$FireplaceQu)] = 'None'\n```\n\n\n- **Alley: Type of alley access**\n\nThere are 2721 missing values for Alley and only 2 potential options - Grvl and Pave. We can fill 'None' for any of the houses with NA's as these houses must not have any type of alley access. \n\n```{r warning=FALSE, message=FALSE}\nplot.categoric('Alley', df.combined)\ndf.combined$Alley[is.na(df.combined$Alley)] = 'None'\n```\n\n```{r warning=FALSE, message=FALSE}\npaste('There are', sum(sapply(df.combined, is.na)), 'missing values left')\n```\n\n##Adding custom numeric features\n\nNow that we've filled in all missing values for both the training and testing sets we can split our data into a numeric set and a categoric set. Since we want our dataset to be strictly numeric values while retaining as much information as possible, we will have to transform any categoric into a binary feature using one-hot encoding. First off, we can start by adding all our numeric features to a new dataframe along with adding any extra custom made features that will help with predictive modeling.\n\nWe can start by creating a new data frame of just the numeric features\n\n```{r warning=FALSE, message=FALSE}\nnum_features <- names(which(sapply(df.combined, is.numeric)))\ncat_features <- names(which(sapply(df.combined, is.character)))\n\ndf.numeric <- df.combined[num_features]\n```\n\nNext we can transform any of the ordinal variables (variables that can be scaled) into numeric values. We can do this by determining which order the categories follow and assigning the values an order from 1,2,..,n. We'll group each feature by its possible values and return the median SalePrice and mean OverallQual for each unique value, then map the higher priced/better quality homes larger numeric values and the lower priced/lower quality homes smaller numeric values. \n\n```{r warning=FALSE, message=FALSE}\ngroup.df <- df.combined[1:1460,]\ngroup.df$SalePrice <- train$SalePrice\n      \n# function that groups a column by its features and returns the mdedian saleprice for each unique feature. \ngroup.prices <- function(col) {\n  group.table <- group.df[,c(col, 'SalePrice', 'OverallQual')] %>%\n    group_by_(col) %>%\n    summarise(mean.Quality = round(mean(OverallQual),2),\n      mean.Price = mean(SalePrice), n = n()) %>%\n    arrange(mean.Quality)\n    \n  print(qplot(x=reorder(group.table[[col]], -group.table[['mean.Price']]), y=group.table[['mean.Price']]) +\n    geom_bar(stat='identity', fill='cornflowerblue') +\n    theme_minimal() +\n    scale_y_continuous(labels = dollar) +\n    labs(x=col, y='Mean SalePrice') +\n    theme(axis.text.x = element_text(angle = 45)))\n  \n  return(data.frame(group.table))\n}\n\n## functional to compute the mean overall quality for each quality\nquality.mean <- function(col) {\n  group.table <- df.combined[,c(col, 'OverallQual')] %>%\n    group_by_(col) %>%\n    summarise(mean.qual = mean(OverallQual)) %>%\n    arrange(mean.qual)\n  \n  return(data.frame(group.table))\n}\n\n\n# function that maps a categoric value to its corresponding numeric value and returns that column to the data frame\nmap.fcn <- function(cols, map.list, df){\n  for (col in cols){\n    df[col] <- as.numeric(map.list[df.combined[,col]])\n  }\n  return(df)\n}\n```\n\nAny of the columns with the suffix 'Qual' or 'Cond' denote the quality or condition of that specific feature. Each of these columns have the potential values: `r unique(df.combined$GarageQual)`. We'll compute the mean house prices for these unique values to get a better sense of what their abbreviations mean. \n\n```{r warning=FALSE, message=FALSE}\nqual.cols <- c('ExterQual', 'ExterCond', 'GarageQual', 'GarageCond', 'FireplaceQu', 'KitchenQual', 'HeatingQC', 'BsmtQual')\n\ngroup.prices('FireplaceQu')\ngroup.prices('BsmtQual')\ngroup.prices('KitchenQual')\n\n```\n\nFrom seeing the mean saleprices from a few of the quality and condition features we can infer that the abbreviations mean **poor**, **fair**, **typical/average**, **good** and **excelent**. We'll map numeric values from 0-5 to their corresponding categoric values (including 0 for **None**) and combine that to our dataframe.\n\n**Note:** we will set 'None' = 0 for all categories as *None* signifies that the house does not have that particular quality/condition to rank and regardless of the houses overall quality or sale price we will keep 'None' = 0 for consistency. \n\n```{r warning=FALSE, mpessage=FALSE}\nqual.list <- c('None' = 0, 'Po' = 1, 'Fa' = 2, 'TA' = 3, 'Gd' = 4, 'Ex' = 5)\n\ndf.numeric <- map.fcn(qual.cols, qual.list, df.numeric)\n```\n\n\n```{r warning=FALSE, message=FALSE}\ngroup.prices('BsmtExposure')\nbsmt.list <- c('None' = 0, 'No' = 1, 'Mn' = 2, 'Av' = 3, 'Gd' = 4)\n\ndf.numeric = map.fcn(c('BsmtExposure'), bsmt.list, df.numeric)\n\n```\n\n`BsmtFinType1` and `BsmtFineType2` represent the quality of the 1st and 2nd finished areas. There should be some order between the different types of qualities, we'll see if we can find a similarity between the 2 features.\n\n```{r warning=FALSE, message=FALSE}\ngroup.prices('BsmtFinType1')\n```\n\n- **BsmtFinType1: Quality of basement finished area**  \n- **BsmtFinSF1: Type 1 finished square feet**  \n\nHere returning the mean sale prices might not be as helpful as computing the median basement areas for both columns to determine which quality is better than the other. \n\n```{r warning=FALSE, message=FALSE}\n# visualization for BsmtFinTyp2 instead of another table\ndf.combined[,c('BsmtFinType1', 'BsmtFinSF1')] %>%\n  group_by(BsmtFinType1) %>%\n  summarise(medianArea = median(BsmtFinSF1), counts = n()) %>%\n  arrange(medianArea) %>%\n  ggplot(aes(x=reorder(BsmtFinType1,-medianArea), y=medianArea)) +\n  geom_bar(stat = 'identity', fill='cornflowerblue') +\n  labs(x='BsmtFinType2', y='Median of BsmtFinSF2') +\n  geom_text(aes(label = sort(medianArea)), vjust = -0.5) +\n  scale_y_continuous(limits = c(0,850)) +\n  theme_minimal()\n```\n\nThrough investigating the relationships between the basement quality and areas we an see the true order of qualities of each basement to be *'None' < 'Unf' < 'LwQ' < 'BLQ' < 'Rec' < 'ALQ' < 'GLQ'*. \n\n```{r warning=FALSE, message=FALSE}\nbsmt.fin.list <- c('None' = 0, 'Unf' = 1, 'LwQ' = 2,'Rec'= 3, 'BLQ' = 4, 'ALQ' = 5, 'GLQ' = 6)\ndf.numeric <- map.fcn(c('BsmtFinType1','BsmtFinType2'), bsmt.fin.list, df.numeric)\n```\n\n- **Functional: Home functionality rating**\n\nThis feature doesn't really tell us much and functionality is very vague to tie which other features have a correlation with it. We can compute the mean sale prices for each functional category and assign numeric values accordingly.\n\n```{r warning=FALSE, message=FALSE}\ngroup.prices('Functional')\nfunctional.list <- c('None' = 0, 'Sal' = 1, 'Sev' = 2, 'Maj2' = 3, 'Maj1' = 4, 'Mod' = 5, 'Min2' = 6, 'Min1' = 7, 'Typ'= 8)\n\ndf.numeric['Functional'] <- as.numeric(functional.list[df.combined$Functional])\n```\n\nWe'll continue to do the same for GarageFinish and Fence:\n\n```{r warning=FALSE, message=FALSE}\ngroup.prices('GarageFinish')\ngarage.fin.list <- c('None' = 0,'Unf' = 1, 'RFn' = 1, 'Fin' = 2)\n\ndf.numeric['GarageFinish'] <- as.numeric(garage.fin.list[df.combined$GarageFinish])\n\n\ngroup.prices('Fence')\nfence.list <- c('None' = 0, 'MnWw' = 1, 'GdWo' = 1, 'MnPrv' = 2, 'GdPrv' = 4)\n\ndf.numeric['Fence'] <- as.numeric(fence.list[df.combined$Fence])\n\nMSdwelling.list <- c('20' = 1, '30'= 0, '40' = 0, '45' = 0,'50' = 0, '60' = 1, '70' = 0, '75' = 0, '80' = 0, '85' = 0, '90' = 0, '120' = 1, '150' = 0, '160' = 0, '180' = 0, '190' = 0)\n\ndf.numeric['NewerDwelling'] <- as.numeric(MSdwelling.list[as.character(df.combined$MSSubClass)])\n\n      \n```\n\nWe've transformed all the categoric features with an ordianl scale into a numeric columns. Let's see which variables have the strongest effect on a houses sale price. \n\nTo determine which features have the strongest relationship with **SalePrice** we can compute the sample correlation coefficient between the 2 variables, $$r_{xy} = \\frac{s_{xy}}{s_xs_y}$$ where $s_{xy} = \\mathbf{E}[(X-\\mathbf{E}[X])(Y-\\mathbf{E}[Y])$ is the sample covariance and $s_x, s_y$ are the sample standard deviations. The correlation coefficient measures the how linearly related the 2 variables are. A coefficient of 0 means that the 2 variables show no linear relationship, a coefficient between (0,1] shows that they have positive relationship and a coefficient between [-1,0) means they have a negative relationship. We're particularly interested in variables that show strong relationship with **SalePrice** so we will focus primarily on features that have a coefficient > .5 or < -.5. \n\n```{r}\n# need the SalePrice column\ncorr.df <- cbind(df.numeric[1:1460,], train['SalePrice'])\n\n# only using the first 1460 rows - training data\ncorrelations <- cor(corr.df)\n# only want the columns that show strong correlations with SalePrice\ncorr.SalePrice <- as.matrix(sort(correlations[,'SalePrice'], decreasing = TRUE))\n\ncorr.idx <- names(which(apply(corr.SalePrice, 1, function(x) (x > 0.5 | x < -0.5))))\n\ncorrplot(as.matrix(correlations[corr.idx,corr.idx]), type = 'upper', method='color', addCoef.col = 'black', tl.cex = .7,cl.cex = .7, number.cex=.7)\n```\n\nFrom the correlation plot we can see the 10 features with the strongest effect on SalePrice.   \n\n - **OverallQual: Overall material and finish quality**  \n - **GrLivArea: Above grade (ground) living area square feet**  \nThese 2 features have the highest correlation and very reasonably make sense.\n\n- **GarageCars: Size of garage in car capacity**  \n- **GarageArea: Size of garage in square feet**  \nThese 2 features from our plot are the next best thing, however, this might not have been something we expected. We can also see that the correlation between the 2 is extremely high, 0.88, which makes sense as the area of the garage is a constraint on how many cars can fit. \n\n- **TotalBsmtSF: Total square feet of basement area**  \n- **1stFlrSF: First Floor square feet**  \nThese features also make intuitive sense as anything corresponding to area/size of the house will have an effect on the price. We can also see that these 2 features have a strong linear relationship with one another, which makes sense as the size of the basement can certainly depend on the size of the houses 1st floor. \n\n**FullBath: Full bathrooms above grade**  \n**TotRmsAbvGrd: Total rooms above grade (does not include bathrooms)**  \nSomething we might have expected as well is that the number of rooms in the house having a relationship with the houses price. We can further see that the strong correlation between **GrLivArea** and **TotRmsAbvGrd** since the size of the livign area will most likely be a contstraint on the number of rooms above ground. An interesting relationship we might want to look into are the relationship between houses with a small living area but many rooms, which will result in smaller rooms and vise versa. We may want to check to see if this is an indicator on higher/lower house prices. \n\n**YearBuilt: Original construction date**  \n**YearRemodAdd: Remodel date**  \nA positive correlation for both of these is not something we should be surprised by. The newer homes will likely give higher listings compared to older models. \n\nWe can print a matrix of scatter plots to see what these relationships look like under the hood to get a better sense of whats going on. \n\n```{r warning=FALSE, message=FALSE}\nrequire(GGally)\nlm.plt <- function(data, mapping, ...){\n   plt <- ggplot(data = data, mapping = mapping) + \n    geom_point(shape = 20, alpha = 0.7, color = 'darkseagreen') +\n    geom_smooth(method=loess, fill=\"red\", color=\"red\") +\n    geom_smooth(method=lm, fill=\"blue\", color=\"blue\") +\n    theme_minimal()\n  return(plt)\n}\n\nggpairs(corr.df, corr.idx[1:6], lower = list(continuous = lm.plt))\n```\n\nThe blue lines in the scatter plots represent a simple linear regression fit while the red lines represent a local polynomial fit. We can see both OverallQual and GrLivArea and TotalBsmtSF follow a linear model, but have some outliers we may want to look into. For instance, there are multiple houses with an overall quality of 10, but have suspisciously low prices. We can see similar behavior in GrLivArea and TotalBsmtSF. GarageCars and GarageArea both follow more of a quadratic fit. It seems that having a 4 car garage does not result in a higher house price and same with an extremely large area. \n\n```{r warning=FALSE, message=FALSE}\nggpairs(corr.df, corr.idx[c(1,7:11)], lower = list(continuous = lm.plt))\n```\n\nMore of the same with the remaining features with 1stFlrSF, FullBath, TotRmsAbvGrd following linear model while YearBuilt and YearRemodAdd both having non-linear/quadratic models. Taking a closer look to YearBuilt and YearRemodAdd we can see that the most expensive homes are the most recently built and remodelled. \n\n\nNow for some of the nominal variables we can take one of the categories that is distict from the others and create a binary feature that returns 1 if the house has that specific value and 0 if it does not.\n\n```{r warning=FALSE, message=FALSE}\nplot.categoric('LotShape', df.combined)\n```\n\nLotShape has 3 values for having an irregular shape and only 1 for regular. We can create a binary column that returns 1 for houses with a regular lot shape and 0 for houses with any of the 3 irregular lot shapes. Using this method of turning a categoric feature into a binary column will ultimately  help our data train better through boosted models without using numeric placeholders on nominal data. \n\n```{r warning=FALSE, message=FALSE}\ndf.numeric['RegularLotShape'] <- (df.combined$LotShape == 'Reg') * 1\n```\n\nWe'll use this exact same method for:\n\n**LandContour: Flatness of the property**  \n**LandSlope: Slope of property**  \n**Electrical: Electrical system**  \n**GarageType: Garage location**  \n**PavedDrive: Paved driveway**  \n**MiscFeature: Miscellaneous feature not covered in other categories** \n\n```{r warning=FALSE, message=FALSE}\nplot.categoric('LandContour', df.combined)\n\ndf.numeric['LandLeveled'] <- (df.combined$LandContour == 'Lvl') * 1\n\nplot.categoric('LandSlope', df.combined)\n\ndf.numeric['LandSlopeGentle'] <- (df.combined$LandSlope == 'Gtl') * 1\n\nplot.categoric('Electrical', df.combined)\n\ndf.numeric['ElectricalSB'] <- (df.combined$Electrical == 'SBrkr') * 1\n\nplot.categoric('GarageType', df.combined)\n\ndf.numeric['GarageDetchd'] <- (df.combined$GarageType == 'Detchd') * 1\n\nplot.categoric('PavedDrive', df.combined)\n\ndf.numeric['HasPavedDrive'] <- (df.combined$PavedDrive == 'Y') * 1\n\ndf.numeric['HasWoodDeck'] <- (df.combined$WoodDeckSF > 0) * 1\n\ndf.numeric['Has2ndFlr'] <- (df.combined$X2ndFlrSF > 0) * 1\n\ndf.numeric['HasMasVnr'] <- (df.combined$MasVnrArea > 0) * 1\n```\n\n```{r warning=FALSE, message=FALSE}\nplot.categoric('MiscFeature', df.combined)\n```\n\nFor `MiscFeature` the only feature with a significant amount of houses having it is *Shed*. We can one-hot encode houses that have Sheds vs those who do not. \n\n```{r warning=FALSE, message=FALSE}\ndf.numeric['HasShed'] <- (df.combined$MiscFeature == 'Shed') * 1\n```\n\n**YearBuilt: Original construction date**  \n**YearRemodAdd: Remodel date**  \n\nMany of the houses recorded the same year for `YearBuilt` and `YearRemodAdd`. We can create a new column that records that a house was remodelled if the year it was built is different than the remodel year. This \n\n```{r warning=FALSE, message=FALSE}\ndf.numeric['Remodeled'] <- (df.combined$YearBuilt != df.combined$YearRemodAdd) * 1\n```\n\nWe can also create a column that seperates which houses have been recently remodelled vs those who are not. Houses that have been remodelled after the year they were sold will fall into this category. \n\n```{r warning=FALSE, message=FALSE}\ndf.numeric['RecentRemodel'] <- (df.combined$YearRemodAdd >= df.combined$YrSold) * 1\n```\n\nThere can be potential value to homes who were sold the same year they were built as this could be an indicator that these houses were hot in the market. \n\n```{r warning=FALSE, message=FALSE}\ndf.numeric['NewHouse'] <- (df.combined$YearBuilt == df.combined$YrSold) * 1\n```\n\nWhat about the houses with area based features equal to 0? Houses with 0 square footage for a columnshows that the house does not have that feature at all. We add a one-hot encoded column for returning 1 for any house with an area greater than 0 since this means that the house *does* have this feature and 0 for those who do not! \n\n```{r warning=FALSE, message=FALSE}\n#cols.binary <- c('X2ndFlrSF', 'MasVnrArea', 'WoodDeckSF')\ncols.binary <- c('X2ndFlrSF', 'MasVnrArea', 'WoodDeckSF', 'OpenPorchSF', 'EnclosedPorch', 'X3SsnPorch', 'ScreenPorch')\n\nfor (col in cols.binary){\n  df.numeric[str_c('Has',col)] <- (df.combined[,col] == 0) * 1\n}\n```\n\nWe know how important the year a house was built and sold but what about what the specific month it was sold? How do houses sold during summer compare to the other seasons? \n\n```{r warning=FALSE, message=FALSE}\nggplot(df.combined, aes(x=MoSold)) +\n  geom_bar(fill = 'cornflowerblue') +\n  geom_text(aes(label=..count..), stat='count', vjust = -.5) +\n  theme_minimal() +\n  scale_x_continuous(breaks = 1:12)\n```\n\nThe largest proportion of houses sold is during the summer months: May, June, July. Let's add a column that seperates the the summer houses from the rest. \n\n```{r warning=FALSE, message=FALSE}\ndf.numeric['HighSeason'] <- (df.combined$MoSold %in% c(5,6,7)) * 1\n```\n\nWhat about which Neighborhoods are more expensive than others? \n\n```{r warning=FALSE, message=FALSE, results=FALSE}\ntrain[,c('Neighborhood','SalePrice')] %>%\n  group_by(Neighborhood) %>%\n  summarise(median.price = median(SalePrice, na.rm = TRUE)) %>%\n  arrange(median.price) %>%\n  mutate(nhbr.sorted = factor(Neighborhood, levels=Neighborhood)) %>%\n  ggplot(aes(x=nhbr.sorted, y=median.price)) +\n  geom_point() +\n  geom_text(aes(label = median.price, angle = 45), vjust = 2) +\n  theme_minimal() +\n  labs(x='Neighborhood', y='Median price') +\n  theme(text = element_text(size=12),\n        axis.text.x = element_text(angle=45))\n```\n\n\nStoneBr, NoRidge, NridgHt have a large gap between them versus the rest of the median prices from any of the other neighborhods. It would be wise of us to check if this is from outliers or if these houses are much pricier as a whole. \n\n```{r warning=FALSE, message=FALSE}\nother.nbrh <- unique(df.combined$Neighborhood)[!unique(df.combined$Neighborhood) %in% c('StoneBr', 'NoRidge','NridgHt')]\n\nggplot(train, aes(x=SalePrice, y=GrLivArea, colour=Neighborhood)) +\n  geom_point(shape=16, alpha=.8, size=4) +\n  scale_color_manual(limits = c(other.nbrh, 'StoneBr', 'NoRidge', 'NridgHt'), values = c(rep('black', length(other.nbrh)), 'indianred',\n                                    'cornflowerblue', 'darkseagreen')) +\n  theme_minimal() +\n  scale_x_continuous(label=dollar)\n```\n\n3 houses from StoneBr, NoRidge and NridgHt with house prices over $500,000 which no other Neighborhood is in the same range. What pops out even more in this plot is the 2 houses with an enormous GrLivArea of over 4500 square ft yet very low sale prices. We certianly have an opportunity to explore these outliers in depth, we'll take a look at this later. \n\nIn the mean time lets one-hot encode the more expensive neighborhoods and add that to our dataframe\n\n```{r warnings=FALSE, message=FALSE}\nnbrh.rich <- c('Crawfor', 'Somerst, Timber', 'StoneBr', 'NoRidge', 'NridgeHt')\ndf.numeric['NbrhRich'] <- (df.combined$Neighborhood %in% nbrh.rich) *1\n```\n\nHow about a numeric mapping to the neighborhoods who have higher quality homes and run for larger sale prices?\n\n```{r}\ngroup.prices('Neighborhood')\n\nnbrh.map <- c('MeadowV' = 0, 'IDOTRR' = 1, 'Sawyer' = 1, 'BrDale' = 1, 'OldTown' = 1, 'Edwards' = 1, \n             'BrkSide' = 1, 'Blueste' = 1, 'SWISU' = 2, 'NAmes' = 2, 'NPkVill' = 2, 'Mitchel' = 2,\n             'SawyerW' = 2, 'Gilbert' = 2, 'NWAmes' = 2, 'Blmngtn' = 2, 'CollgCr' = 2, 'ClearCr' = 3, \n             'Crawfor' = 3, 'Veenker' = 3, 'Somerst' = 3, 'Timber' = 3, 'StoneBr' = 4, 'NoRidge' = 4, \n             'NridgHt' = 4)\n\ndf.numeric['NeighborhoodBin'] <- as.numeric(nbrh.map[df.combined$Neighborhood])\n```\n\n**SaleCondition:** Condition of sale\n\n```{r warning=FALSE, message=FALSE}\ngroup.prices('SaleCondition')\n```\n\nTried to do some research to get a sense of what the terms mean for SaleCondition but couldn't find much. The houses with 'Partial' for SaleCondition have both the highest quality and highest sale price well above the other qualities. Instead of mapping each quality to its own numeric value we can one hot encode for houses with *Partial*\n\n```{r warning=FALSE, message=FALSE}\ndf.numeric['PartialPlan'] <- (df.combined$SaleCondition == 'Partial') * 1\n\ngroup.prices('HeatingQC')\n\nheating.list <- c('Po' = 0, 'Fa' = 1, 'TA' = 2, 'Gd' = 3, 'Ex' = 4)\n\ndf.numeric['HeatingScale'] <- as.numeric(heating.list[df.combined$HeatingQC])\n```\n\n\n**1stFlrSF:** First Floor square feet  \n**2ndFlrSF:** Second floor square feet  \n**LowQualFinSF:** Low quality finished square feet (all floors)  \n1stFlrSF + 2nFlrSF + LowQualFinSF = GrLivArea. \n\n```{r warning=FALSE, message=FALSE}\narea.cols <- c('LotFrontage', 'LotArea', 'MasVnrArea', 'BsmtFinSF1', 'BsmtFinSF2', 'BsmtUnfSF',\n             'TotalBsmtSF', 'X1stFlrSF', 'X2ndFlrSF', 'GrLivArea', 'GarageArea', 'WoodDeckSF', \n             'OpenPorchSF', 'EnclosedPorch', 'X3SsnPorch', 'ScreenPorch', 'LowQualFinSF', 'PoolArea')\n\ndf.numeric['TotalArea'] <- as.numeric(rowSums(df.combined[,area.cols]))\n\n#paste('There are', sum((df.combined$X1stFlrSF + df.combined$X2ndFlrSF) != df.combined$GrLivArea), 'houses with LowQualFinSF > 0')\n```\n\n\n```{r warning=FALSE, message=FALSE}\ndf.numeric['AreaInside'] <- as.numeric(df.combined$X1stFlrSF + df.combined$X2ndFlrSF)\n```\n\nWe've seen how strong of an effect the year of a house built has on the house price, therefore, as this dataset collects houses up until 2010 we can determine how old a house is and how long ago the house was sold:\n\n```{r warning=FALSE, message=FALSE}\ndf.numeric['Age'] <- as.numeric(2010 - df.combined$YearBuilt)\n\ndf.numeric['TimeSinceSold'] <- as.numeric(2010 - df.combined$YrSold)\n\n# how many years since the house was remodelled and sold \ndf.numeric['YearSinceRemodel'] <- as.numeric(df.combined$YrSold - df.combined$YearRemodAdd)\n```\n\nCorrelation plot with OverallQual\n```{r warnings=FALSE, message=FALSE}\ncorr.OverallQual <- as.matrix(sort(correlations[,'OverallQual'], decreasing = TRUE))\n\ncorr.idx <- names(which(apply(corr.OverallQual, 1, function(x) (x > 0.5 | x < -0.5))))\n\ncorrplot(as.matrix(correlations[corr.idx, corr.idx]), type = 'upper',\n         method = 'color', addCoef.col = 'black', tl.cex =.7, cl.cex = .7,\n         number.cex = .7)\n```\n\nWe may want to use PCA and go more in depth, if we have time we'll come back to this\n\n(we didn't have time ): )\n\n##Outliers\n\nEarlier we saw some suspicious houses with abnormally large GrLivArea's, 2 of which had very low SalePrices. These outliers may disrupt our ability to accurately predict. Lets take a closer look at these values and see if we may want to remove them\n\n```{r warning=FALSE, message=FALSE}\ntrain.test.df <- rbind(dplyr::select(train,-SalePrice), test)\ntrain.test.df$type <- c(rep('train',1460),rep('test',1459))\n\nggplot(train, aes(x=GrLivArea)) +\n  geom_histogram(fill='indianred',color='black') +\n  theme_minimal()\n\noutlier_values <- boxplot.stats(train$GrLivArea)$out  # outlier values.\nboxplot(train$GrLivArea, main=\"GrLivArea\", boxwex=0.1)\nmtext(paste(\"Outliers: \", paste(outlier_values[outlier_values>4000], collapse=\", \")), cex=0.6)\n\nggplot(train.test.df, aes(x=type, y=GrLivArea, fill=type)) +\n  geom_boxplot() +\n  theme_minimal()\n```\n\nFor the training data we can see 4 houses whose GrLivArea is greater than 4000 yet there is one in the testing set. While it is always a great option to remove outliers from our data as they are usually telling us something more than meets the eye about what is going on with the data, these houses in the trainng set are obnoxiously large and ultimately do not add much value and are causing heavy skewness in both the SalePrice and GrLivArea and particularly the 2 values that have above a 4000 GrLivArea but low SalePrice are putting a constraint on the correlation between the 2 variables. Lets throw these houses out of training set begin preprocessing our data now that there are no heavy outliers. \n\n```{r warning=FALSE, message=FALSE}\nidx.outliers <- which(train$GrLivArea > 4000)\ndf.numeric <- df.numeric[!1:nrow(df.numeric) %in% idx.outliers,]\ndf.combined <- df.combined[!1:nrow(df.combined) %in% idx.outliers,]\ndim(df.numeric)\n```\n\n\n##PCA\n\nI unfortunately did not make use of this, if you have a strong familiarity this could certainly improve your score. \n\n```{r warning=FALSE, message=FALSE}\nrequire(factoextra)\npmatrix <- prcomp(df.numeric, center = TRUE, scale. = TRUE)\n\npcaVar <- as.data.frame(c(get_pca_var(pmatrix)))\n\n# lets\npcaVarNew <- pcaVar[, 1:10]\n```\n\n##Preprocessing\n\nIf we want to use any type of linear regression model an important assumption we need to check is for normality in any of the dependant variables. We can use a Kolmogorov-Smirnof test or compute the skewness/kurtosis in each column to verify normality. A Kolmogorov-Smirnof test compares the sample distribution to a normal and returns a p-value determining if the the 2 distributions are similar. Skewness is a measure of symmetry where distributions with 0 skew follow a normal shape. Kurtosis measures the taildness of the distribution. For skewnesses outside the range of -0.8 to 0.8 and kurtosises outside the of -3.0 to 3.0 do not satisfy the assumption of normality  For any features that are not normally distributed we can make a non-linear transformation like a log-transformation such that $f(x)=log(x+1)$ when a column has 0 and $f(x)=log(x)$ when there are no 0's in the column. We do this because $log(0)=-\\infty$. We will also scale all of the numeric data by standardizing the data (opposed to normalizing) as we know our data has potential outliers we don't want to bound each column. To standardize the observations at indivisual column we compute $$z_{ij} = \\frac{x_{ij}-\\bar{x_j}}{s_j}$$ where $\\bar{x_j}$ is the sample mean at column *j* and $s_j$ is the sample deviation at column *j*. \n\n```{r warning=FALSE, message=FALSE}\nrequire(psych)\n# linear models assume normality from dependant variables \n# transform any skewed data into normal\nskewed <- apply(df.numeric, 2, skewness)\nskewed <- skewed[(skewed > 0.8) | (skewed < -0.8)]\n\nkurtosis <- apply(df.numeric, 2, kurtosi)\nkurtosis <- kurtosis[(kurtosis > 3.0) | (kurtosis < -3.0)]\n\n# not very useful in our case\nks.p.val <- NULL\nfor (i in 1:length(df.numeric)) {\n  test.stat <- ks.test(df.numeric[i], rnorm(1000))\n  ks.p.val[i] <- test.stat$p.value\n}\n\nfor(col in names(skewed)){\n  if(0 %in% df.numeric[, col]) {\n    df.numeric[,col] <- log(1+df.numeric[,col])\n  }\n  else {\n    df.numeric[,col] <- log(df.numeric[,col])\n  }\n}\n\n# normalize the data\nscaler <- preProcess(df.numeric)\ndf.numeric <- predict(scaler, df.numeric)\n\n```\n\nFor the rest of the categoric features we can one-hot encode each value to get as many splits in the data as possible  \n\n```{r warning=FALSE, message=FALSE}\n# one hot encoding for categorical data\n# sparse data performs better for trees/xgboost\ndummy <- dummyVars(\" ~ .\",data=df.combined[,cat_features])\ndf.categoric <- data.frame(predict(dummy,newdata=df.combined[,cat_features]))\n```\n\nWhat about YearBuilt, GarageYrBlt and YearRemodAdd?\n\nYearBuilt had a correlation coefficient of 0.57 with SalePrice, GarageYrBlt had a coefficiient of 0.56 and YearRemodAdd had scored a 0.55. Knowing how important these features are we want to make as much use with them as possible. The houses in our data start from 1871 and were built up until 2010. We can bin houses into sequences of 20, which will give us 7 different bins for a feature built in a year to fall into. This will allow us to differentiate the different times/era houses, garages and remodeling took place. \n\n```{r warning=FALSE, message=FALSE}\n# every 20 years create a new bin\n# 7 total bins\n# min year is 1871, max year is 2010!\nyear.map = function(col.combined, col.name) {\n  for (i in 1:7) {\n    year.seq = seq(1871+(i-1)*20, 1871+i*20-1)\n    idx = which(df.combined[,col.combined] %in% year.seq)\n    df.categoric[idx,col.name] = i\n  }\n  return(df.categoric)\n}\n\n```\n\n```{r warning=FALSE, message=FALSE}\n# we'll c\ndf.categoric['GarageYrBltBin'] = 0\ndf.categoric <- year.map('GarageYrBlt', 'GarageYrBltBin')\ndf.categoric['YearBuiltBin'] = 0\ndf.categoric <- year.map('YearBuilt','YearBuiltBin')\ndf.categoric['YearRemodAddBin'] = 0\ndf.categoric <- year.map('YearRemodAdd', 'YearRemodAddBin')\n```\n\nNow that we 3 new columns that generalize what year a house, garage and remodeling took place we'll need to one-hot encode these columns so that each bin is turned into a binary column. The new columns are ranged from 1-7, but we don't know what specific order they follow so it will benefit us more to give each bin its own column. \n\n```{r warning=FALSE, message=FALSE}\nbin.cols <- c('GarageYrBltBin', 'YearBuiltBin', 'YearRemodAddBin')\n\nfor (col in bin.cols) {\n  df.categoric <- cbind(df.categoric, model.matrix(~.-1, df.categoric[col]))\n}\n\n# lets drop the orginal 'GarageYrBltBin', 'YearBuiltBin', 'YearRemodAddBin' from our dataframe\ndf.categoric <- df.categoric[,!names(df.categoric) %in% bin.cols]\n```\n\nWe're finally done clearning, manipulating and adding features to our data. We'll combine the numeric and categoric dataframes into one, which we will use to build or models on. \n\n```{r warning=FALSE, message=FALSE}\ndf <- cbind(df.numeric, df.categoric)\n```\n\nWhat does our distribution of housing prices look like?\n\n```{r warning=FALSE, message=FALSE}\nrequire(WVPlots)\ny.true <- train$SalePrice[which(!1:1460 %in% idx.outliers)]\n\nqplot(y.true, geom='density') +# +(train, aes(x=SalePrice)) +\n  geom_histogram(aes(y=..density..), color='black', \n                 fill='cornflowerblue', alpha=.5, bins = 75) +\n  geom_line(aes(y=..density..), color='cornflowerblue', lwd = 1, stat = 'density') + \n  stat_function(fun = dnorm, colour = 'indianred', lwd = 1, args = \n                  list(mean(train$SalePrice), sd(train$SalePrice))) +\n  scale_x_continuous(breaks = seq(0,800000,100000), labels = dollar) +\n  scale_y_continuous(labels = comma) +\n  theme_minimal() +\n  annotate('text', label = paste('skewness =', signif(skewness(train$SalePrice),4)),\n           x=500000,y=7.5e-06)\n\nqqnorm(train$SalePrice)\nqqline(train$SalePrice)\n```\n\nWe can see from the histogram and the quantile-quantile plot that the distribution of sale prices is right-skewed and does not follow a normal distribution. Lets make a log-transformation and see how our data looks\n\n```{r warning=FALSE, message=FALSE}\ny_train <- log(y.true+1)\n\nqplot(y_train, geom = 'density') +\n  geom_histogram(aes(y=..density..), color = 'black', fill = 'cornflowerblue', alpha = .5, bins = 75) +\n  scale_x_continuous(breaks = seq(0,800000,100000), labels = comma) +\n  geom_line(aes(y=..density..), color='dodgerblue4', lwd = 1, stat = 'density') + \n  stat_function(fun = dnorm, colour = 'indianred', lwd = 1, args = \n                  list(mean(y_train), sd(y_train))) +\n  #scale_x_continuous(breaks = seq(0,800000,100000), labels = dollar) +\n  scale_y_continuous(labels = comma) +\n  theme_minimal() +\n  annotate('text', label = paste('skewness =', signif(skewness(y_train),4)),\n           x=13,y=1) +\n  labs(x = 'log(SalePrice + 1)') \n\nqqnorm(y_train)\nqqline(y_train)\n```\n\n```{r}\npaste('The dataframe has', dim(df)[1], 'rows and', dim(df)[2], 'columns')\n```\n\nWe've manipulated a lot of variables and added many features, 345 to be exact, in our dataset and their could potentially be some variables that won't give our data any value when we're modeling. Some of these features may have become zero-variance predictors, such that a few samples may have an insignificant influence on the model. These *near-zero-variance* may cause overfitting or will prevent our model from generalizing over the data at a more sufficient rate. The package `caret` offers a function `nearZeroVar`, which checks the frequency of the most common value over the second most frequent value, which would be closer to 1 for well-behaved predictors and very large for highly-unbalanced features. It also checks the number of unique values divided by the *n* number of samples which will approach zero as the level of detail in the feature increases. We can remove all of the near-zero-variance variables from out dataframe.\n\n```{r warning=FALSE, message=FALSE}\nnzv.data <- nearZeroVar(df, saveMetrics = TRUE)\n\n# take any of the near-zero-variance perdictors\ndrop.cols <- rownames(nzv.data)[nzv.data$nzv == TRUE]\n\ndf <- df[,!names(df) %in% drop.cols]\n\npaste('The dataframe now has', dim(df)[1], 'rows and', dim(df)[2], 'columns')\n```\n\n\nOur new distribution with the transformed data follows much closer to a normal distribution and we can verify this from the quantile-quantile plot. Now that our independent and dependent variables satisfy the assumption of normality we can begin building our model.\n\n**XGBoost** fits shallow regression trees to our data and then additional trees to the residuals, we'll repeat this process for 30000 rounds so that our model has learned from the data as much as possible without overfitting. XGBoost is a **Gradient Boosted Method (GBM)**, which is an ensemble learning method that uses a very large number of decision trees, which are typically weak learners and combines them into one final prediction. For gradient boosted trees, the new trees added to the model are the weak learnings where $$F_0=0, \\quad F_t(x)=F_{t-1}(x)+h(x)$$ suchat that $F(x)$ is the entire model after time $t-1$ and $h(x)$ is the new weak learner (new tree) that will be added to our model. In particular for XGBoost we will minimize the following objective function at time *t* such that $$Obj(F_t)=L(F_{t-1}+F_t) + \\Omega(F_t)$$ such that $L(F_t)$ is our loss function and $\\Omega(F_t)$ is the regularization function. In the XGBoost package the regularization function is computed such that $$\\Omega(F_t) = \\gamma T+\\frac{1}{2}\\sum_{j=1}^Tw_j^2$$ where $w_j$ is the score of the $j^{th}$ leaf, $\\lambda$ is the leaf weight penalty, $\\gamma$ is the tree size penalty and *T* represents the number of leaves in the tree. When we call `xgb.train` from the `XGBoost` package we will choose which parameters minimize the loss in our model using the `xgb.csv` by searching through a grid of parameters. The parameters we'll be interested in *tuning* is:\n\n$\\eta$ - Shrinkage term  \n$\\gamma$ - Tree size penalty  \n$\\lambda$ - $L^2$ leaf node weight penalty  \n*Max Depth* -  The maximum depth of each tree  \n*Subsample* -  proportion of data for ”bagging” i.e. randomly sampling with replacement  \n*Min Child Weight* -  The minimum weight that a node can have\n\n\nOne limitation to using GBM's and XGBoost in particular is its inability to extrapolate and because of this we can use linear model to better predict any sale prices outside the range of prices given in our training set.\n\nWe know there exists multicollinearity in our dependent variables as area features are a determinant for a house having a certain amount of rooms, we know that the garage variables have heavy dependency and the list goes on. Due to this a simple linear regression model will not be of much help to predict accurate sale prices, which is why we can make use of both **ridge** and **lasso** regression. The Ridge penalty is known to shrink the coefficients of correlated predictors towards each other with the use of the $\\ell^2$-norm, while the lasso tends to pick one of them and discard the others by construct of the $\\ell^1$-norm. Adding the $\\ell^1$ and $\\ell^2$ penalties give a nice contstraint on the coefficients of our model and solve our problem of having collinear variables. Another useful property of these regression models is their ability to *extrapolate*, i.e. they can predict house prices that our outside of the range of prices we were given in our training set. Along with Ridge and Lasso we will use  elastic-net regularization which can be derived such that, $$min_{\\beta_0,\\beta}\\frac{1}{N}\\sum_{n=1}^Nw_il(y_i,\\beta_0+\\beta^Tx_i) + \\lambda[(1-\\alpha)||\\beta||^2_2/2+\\alpha||\\beta||_1]$$\nwhere $l(y,n)$ is the negative log-likelihood contribution at observation *i* and $\\lambda$ is a shrinkage parameter, when $\\lambda=0$, no shrinkage will be performed and and as $\\lambda$ increases the coefficients are shrunken at a larger rate. Elastic-net has a great property such that when we call `glmnet`, the equation is controlled by $\\alpha$, which leverages the gap between ridge and lasso. When $\\alpha = 0$ we have $$min_{\\beta_0,\\beta}\\frac{1}{N}\\sum_{n=1}^Nw_il(y_i,\\beta_0+\\beta^Tx_i) + \\lambda[(1-\\alpha)||\\beta||^2_2/2]$$ which is our equation for ridge and when $\\alpha=1$ we have, $$min_{\\beta_0,\\beta}\\frac{1}{N}\\sum_{n=1}^Nw_il(y_i,\\beta_0+\\beta^Tx_i) + \\lambda[\\alpha||\\beta||_1]$$ which is our requation for lasso. \n\nOnce we have made predictions with all of our models we can take the mean of the 4 predictions and let that be our final prediction. \n\nTo better estimate the test error of a predictive model we'll use **K-fold cross-validation**. For K-fold cross-validaiton the observations in our data are split into K partitions, then our model is trained on the K – 1 partitions, where the test error is predicted on the left out partition k. We repeat this process for k = 1,2…K times and we will average the results. To score how well our model predicts output we will take the **root mean squared error (RMSE)**. The RMSE can be computed such that $$RMSE = \\sqrt{\\frac{1}{N}\\sum_{i=1}^N(y_i-\\hat{y}_i)^2}$$ The RMSE is one of the most used error metrics used in practice and gives us a good score to determine how well our model trains on new data, specifically through the use of cross-validation. \n\n\n\n```{r warning=FALSE, message=FALSE}\nx_train <- df[1:1456,]\n\nx_test <- df[1457:nrow(df),]\n\ndtrain <- xgb.DMatrix(as.matrix(x_train), label = y_train)\ndtest <- xgb.DMatrix(as.matrix(x_test))\n```\n\n\n`expand.grid` is your best friend when it comes to parameter tuning. The code below is a baseline approach, however, you should have a set of values you would like to try and run yourself. I won't run this in the kernel as this would take too long.\n`xgb.cv` is also a very useful function that will show you how well your model generalizes to testing data. To avoid overfit `early_stopping_rounds` is a great way to find at which point your model begins to overfit, which will change based on the paramters used.\n```{r warning=FALSE, message=FALSE}\n\ncv.ctrl <- trainControl(method = \"repeatedcv\", repeats = 1,number = 4, \n                        allowParallel=T)\n\n    xgb.grid <- expand.grid(nrounds = 750,\n        eta = c(0.01,0.005,0.001),\n        max_depth = c(4,6,8),\n        colsample_bytree=c(0,1,10),\n        min_child_weight = 2,\n        subsample=c(0,0.2,0.4,0.6),\n        gamma=0.01)\nset.seed(45)\n    #xgb_tune <- train(as.matrix(x_train),\n    #        y_train,\n    #        method=\"xgbTree\",\n    #        trControl=cv.ctrl,\n    #        tuneGrid=xgb.grid,\n    #        verbose=T,\n    #        metric=\"RMSE\",\n    #        nthread =3)\n\nxgb_params <- list(\n  booster = 'gbtree',\n  objective = 'reg:linear',\n  colsample_bytree=1,\n  eta=0.005,\n  max_depth=4,\n  min_child_weight=3,\n  alpha=0.3,\n  lambda=0.4,\n  gamma=0.01, # less overfit\n  subsample=0.6,\n  seed=5,\n  silent=TRUE)\n\n#xgb.cv(xgb_params, dtrain, nrounds = 5000, nfold = 4, early_stopping_rounds = 500)\n```\n\n```{r warning=FALSE, message=FALSE}\nbst <- xgb.train(xgb_params,dtrain, nrounds = 1000)#, early_stopping_rounds = 300, watchlist = list(train=dtrain))\n```\n\n**Running XGBoost in a Kaggle Kernel is computationally heavy with large datasets so here I am just using `nrounds = 1000` as an example, but determining the right amount of `nrounds` for you model relies heavily on $\\eta$. I would recammend `nrounds = 10000` and `eta = 0.01` as a starter.\nA very effective way of choosing optimal parameters is with the use of `expand.grid`, however, this can take quite a while to let many models train over your data, I would strongly recammend reading up on the XGBoost and GBM's in general.**\n\nThis is a very good reference: https://www.slideshare.net/ShangxuanZhang/kaggle-winning-solution-xgboost-algorithm-let-us-learn-from-its-author\n\nXGBoost has an extremely useful function called `xgb.plot.importance`, which plots the **feature importance** of the model.  \n\nFeature importance is computed by averaging the gain of each feature for all split and all trees in the model. We can take a look at the 10 most important features used in our model. \n\n```{r warning=FALSE, message=FALSE}\n#model.names <- dimnames(dtrain)[[2]]\n\n#importance_matrix <- xgb.importance(model.names, model = bst)\n\n#xgb.plot.importance(importance_matrix[1:10])\n```\n\nHaving the opportunity to see which features are most important allows us to give an emphasis on making use of specific features to improve our model even more. We can also look deeper in the model to see which features are adding little to no value for predictions. Certainly somethig for us to consider. \n\n## How well did our model do?\n\n```{r warning=FALSE, message=FALSE}\nrmse_eval <- function(y.true, y.pred) {\n  mse_eval <- sum((y.true - exp(y.pred)-1)^2) / length(y.true)\n  return(sqrt(mse_eval))\n}\n\n#y_pred.xgb <- predict(bst, dtrain)\n#rmse_eval(y.true, y_pred.xgb)\n```\n\nHow accurate is the RMSE that our XGBoost produced? Lets see how well the linear models train on the data for comparison. \n\n\nLucky for us the `glmnet` package offers a `cv.glmnet` function which will run cross validation for us and pick the $\\lambda$ the produces the smallest error rate. We can call on the same glmnet function and use a ridge regression when $\\alpha=0$, lasso when $\\alpha=1$ and elastic-net when $\\alpha \\in (0,1)$. \n\n```{r warning=FALSE, message=FALSE}\n# ridge, lasso, elasticnet\n\n# these won't run on kaggle uncomment these in your own R-env\n#glm.cv.ridge <- cv.glmnet(as.matrix(x_train), y_train, alpha = 0)\n#glm.cv.lasso <- cv.glmnet(as.matrix(x_train), y_train, alpha = 1)\n#glm.cv.net <- cv.glmnet(data.matrix(x_train), y_train, alpha = 0.001)\n\n# use the lamdba that minimizes the error\n#penalty.ridge <- glm.cv.ridge$lambda.min\n#penalty.lasso <- glm.cv.lasso$lambda.min\n#penalty.net <- glm.cv.net$lambda.min\n```\n\nLets train our model using our chosen $\\lambda$'s\n\n```{r warning=FALSE, message=FALSE}\n#glm.ridge <- glmnet(x = as.matrix(x_train), y = y_train, alpha = 0, lambda = penalty.ridge )\n#glm.lasso <- glmnet(x = as.matrix(x_train), y = y_train, alpha = 1, lambda = penalty.lasso)\n#glm.net <- glmnet(x = as.matrix(x_train), y = y_train, alpha = 0.001, lambda = penalty.net)\n\n#y_pred.ridge <- as.numeric(predict(glm.ridge, as.matrix(x_train)))\n#y_pred.lasso <- as.numeric(predict(glm.lasso, as.matrix(x_train)))\n#y_pred.net <- as.numeric(predict(glm.net, as.matrix(x_train)))\n```\n\n```{r warning=FALSE, message=FALSE}\n#rmse_eval(y.true, y_pred.ridge)\n#rmse_eval(y.true, y_pred.lasso)\n#rmse_eval(y.true, y_pred.net)\n```\n\nHere we have the RMSE for elastic-net, lasso and ridge are all very similar yet not as low as the RMSE we got from XGBoost, *however*, ridge, lasso, and elastic-nets ability to extrapolate saleprices beyond the range we were given in the training set will be crucial for predicting more accurately towards unseen data (future houses). If we combine all 4 of these predictions on our test data by averaging all of our predictions we can get what we hope to be an accurate submission. **Note**: our predictions are in logarithmic form since we made a transformation due to the skewness in the Saleprices so we will need to tranform our predictions back into their original form by taking $f(x) = e^x-1$. \n\n\n```{r warning=FALSE, message=FALSE}\n#y_pred.ridge <- as.double(predict(glm.ridge, as.matrix(x_test)))\n#y_pred.lasso <- as.double(predict(glm.lasso, as.matrix(x_test)))\n#y_pred.net <- as.double(predict(glm.net, as.matrix(x_test)))\n\n#y_pred.ridge <- as.double(exp(y_pred.ridge) - 1)\n#y_pred.lasso <- as.double(exp(y_pred.lasso) - 1)\n#y_pred.net <- as.double(exp(y_pred.net) - 1)\n\n#y_pred.xgb <- as.double(predict(bst, dtest))\n#y_pred.xgb <- as.double(exp(y_pred.xgb) - 1)\n\n# take the average of our predictions for our ensemble\n#y_pred <- (y_pred.xgb + y_pred.ridge + y_pred.lasso + y_pred.net)/4.0\n#head(y_pred)\n```\n\nUncomment everything above for modeling, this ensemble placed top 20%, but can certainly use improvements. Please give a thumbs up if this was helpful in any way it will encourage me to make more kernels!\n\n",
    "created" : 1496948208508.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "405873188",
    "id" : "DCB0A2F8",
    "lastKnownWriteTime" : 1496880306,
    "last_content_update" : 1496880306,
    "path" : "~/STAT 6620/script.Rmd",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}